// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: programs.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createProgram = `-- name: CreateProgram :one
INSERT INTO programs (name, user_id, description, media_urls, visibility)
VALUES (
		$1,
		$2,
		$3,
		$4,
		$5
		)
RETURNING id, name, user_id, description, media_urls, visibility, created_at, updated_at
`

type CreateProgramParams struct {
	Name        string
	UserID      uuid.UUID
	Description string
	MediaUrls   []string
	Visibility  string
}

func (q *Queries) CreateProgram(ctx context.Context, arg CreateProgramParams) (Program, error) {
	row := q.db.QueryRowContext(ctx, createProgram,
		arg.Name,
		arg.UserID,
		arg.Description,
		pq.Array(arg.MediaUrls),
		arg.Visibility,
	)
	var i Program
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.UserID,
		&i.Description,
		pq.Array(&i.MediaUrls),
		&i.Visibility,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProgramDay = `-- name: CreateProgramDay :one
INSERT INTO program_days (program_id, name, description, day_order)
VALUES (
		$1,
		$2,
		$3,
		$4
		)
RETURNING id, program_id, name, description, day_order, created_at
`

type CreateProgramDayParams struct {
	ProgramID   uuid.UUID
	Name        string
	Description string
	DayOrder    int32
}

func (q *Queries) CreateProgramDay(ctx context.Context, arg CreateProgramDayParams) (ProgramDay, error) {
	row := q.db.QueryRowContext(ctx, createProgramDay,
		arg.ProgramID,
		arg.Name,
		arg.Description,
		arg.DayOrder,
	)
	var i ProgramDay
	err := row.Scan(
		&i.ID,
		&i.ProgramID,
		&i.Name,
		&i.Description,
		&i.DayOrder,
		&i.CreatedAt,
	)
	return i, err
}

const createProgramLift = `-- name: CreateProgramLift :one
INSERT INTO program_lifts (program_day_id, exercise_id, description, lift_order, sets, reps)
VALUES (
		$1,
		$2,
		$3,
		$4,
		$5,
		$6
		)
RETURNING id, program_day_id, exercise_id, description, lift_order, sets, reps, created_at
`

type CreateProgramLiftParams struct {
	ProgramDayID uuid.UUID
	ExerciseID   uuid.UUID
	Description  string
	LiftOrder    int32
	Sets         int32
	Reps         int32
}

func (q *Queries) CreateProgramLift(ctx context.Context, arg CreateProgramLiftParams) (ProgramLift, error) {
	row := q.db.QueryRowContext(ctx, createProgramLift,
		arg.ProgramDayID,
		arg.ExerciseID,
		arg.Description,
		arg.LiftOrder,
		arg.Sets,
		arg.Reps,
	)
	var i ProgramLift
	err := row.Scan(
		&i.ID,
		&i.ProgramDayID,
		&i.ExerciseID,
		&i.Description,
		&i.LiftOrder,
		&i.Sets,
		&i.Reps,
		&i.CreatedAt,
	)
	return i, err
}

const getProgram = `-- name: GetProgram :one
SELECT programs.id, programs.name, programs.user_id, programs.description, programs.media_urls, programs.visibility, programs.created_at, programs.updated_at, users.name as author_name
FROM programs
LEFT JOIN users ON programs.user_id = users.id
WHERE programs.id = $1
`

type GetProgramRow struct {
	ID          uuid.UUID
	Name        string
	UserID      uuid.UUID
	Description string
	MediaUrls   []string
	Visibility  string
	CreatedAt   time.Time
	UpdatedAt   time.Time
	AuthorName  sql.NullString
}

func (q *Queries) GetProgram(ctx context.Context, id uuid.UUID) (GetProgramRow, error) {
	row := q.db.QueryRowContext(ctx, getProgram, id)
	var i GetProgramRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.UserID,
		&i.Description,
		pq.Array(&i.MediaUrls),
		&i.Visibility,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AuthorName,
	)
	return i, err
}

const getProgramDayLifts = `-- name: GetProgramDayLifts :many
SELECT p.id, p.program_day_id, p.exercise_id, p.description, p.lift_order, p.sets, p.reps, p.created_at
FROM program_lifts p
LEFT JOIN exercises e ON p.exercise_id = e.id
WHERE program_day_id = $1
ORDER BY lift_order ASC
`

func (q *Queries) GetProgramDayLifts(ctx context.Context, programDayID uuid.UUID) ([]ProgramLift, error) {
	rows, err := q.db.QueryContext(ctx, getProgramDayLifts, programDayID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProgramLift
	for rows.Next() {
		var i ProgramLift
		if err := rows.Scan(
			&i.ID,
			&i.ProgramDayID,
			&i.ExerciseID,
			&i.Description,
			&i.LiftOrder,
			&i.Sets,
			&i.Reps,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProgramDays = `-- name: GetProgramDays :many
SELECT id, program_id, name, description, day_order, created_at
FROM program_days
WHERE program_id = $1
ORDER BY day_order ASC
`

func (q *Queries) GetProgramDays(ctx context.Context, programID uuid.UUID) ([]ProgramDay, error) {
	rows, err := q.db.QueryContext(ctx, getProgramDays, programID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProgramDay
	for rows.Next() {
		var i ProgramDay
		if err := rows.Scan(
			&i.ID,
			&i.ProgramID,
			&i.Name,
			&i.Description,
			&i.DayOrder,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrograms = `-- name: GetPrograms :many
SELECT programs.id, programs.name, programs.user_id, programs.description, programs.media_urls, programs.visibility, programs.created_at, programs.updated_at, users.name as author_name
FROM programs 
LEFT JOIN users 
ON programs.user_id = users.id
ORDER BY programs.created_at DESC
LIMIT 50
`

type GetProgramsRow struct {
	ID          uuid.UUID
	Name        string
	UserID      uuid.UUID
	Description string
	MediaUrls   []string
	Visibility  string
	CreatedAt   time.Time
	UpdatedAt   time.Time
	AuthorName  sql.NullString
}

func (q *Queries) GetPrograms(ctx context.Context) ([]GetProgramsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPrograms)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProgramsRow
	for rows.Next() {
		var i GetProgramsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.UserID,
			&i.Description,
			pq.Array(&i.MediaUrls),
			&i.Visibility,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserSubscribedPrograms = `-- name: GetUserSubscribedPrograms :many
SELECT users_programs.id, users_programs.user_id, users_programs.program_id, users_programs.created_at, users_programs.current_day_order, users_programs.status, programs.name
FROM users_programs
LEFT JOIN programs ON users_programs.program_id = programs.id
WHERE users_programs.user_id = $1
`

type GetUserSubscribedProgramsRow struct {
	ID              uuid.UUID
	UserID          uuid.UUID
	ProgramID       uuid.UUID
	CreatedAt       sql.NullTime
	CurrentDayOrder sql.NullInt32
	Status          sql.NullString
	Name            sql.NullString
}

func (q *Queries) GetUserSubscribedPrograms(ctx context.Context, userID uuid.UUID) ([]GetUserSubscribedProgramsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserSubscribedPrograms, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserSubscribedProgramsRow
	for rows.Next() {
		var i GetUserSubscribedProgramsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProgramID,
			&i.CreatedAt,
			&i.CurrentDayOrder,
			&i.Status,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const subscribeToProgram = `-- name: SubscribeToProgram :exec
INSERT INTO users_programs(
		user_id,
		program_id
) VALUES (
		$1,
		$2
		)
`

type SubscribeToProgramParams struct {
	UserID    uuid.UUID
	ProgramID uuid.UUID
}

func (q *Queries) SubscribeToProgram(ctx context.Context, arg SubscribeToProgramParams) error {
	_, err := q.db.ExecContext(ctx, subscribeToProgram, arg.UserID, arg.ProgramID)
	return err
}
